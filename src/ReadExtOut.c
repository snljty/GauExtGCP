# include <stdio.h>
# include <string.h>

/*  This program read output files from External steps.  */

/*  these functions are defined in fortran programs.  */
/*  only declarations are made here.  */
void writeextspout_(const double * const, const double * const, const double * const, const double * const);
void readgcpgrad_(const char * const, double * const, double * const, double * const);
void writeextgradout_(const double * const, const double * const, const double * const);
void write3zeros_(const int * const);


int main(int argc, const char * const argv[])
{
  char line[BUFSIZ] = "";
  FILE * iflp0 = NULL;  /*  input file generated by Gaussian External  */
  FILE * iflp1 = NULL;  /*  Gaussian temporary output file  */
  FILE * iflp2 = NULL;  /*  gCP output file  */
  FILE * iflp3 = NULL;  /*  gCP gradient  */
  FILE * iflp4 = NULL;  /*  gCP Hessian  */
  unsigned int natoms = 0;
  unsigned int ngrad = 0;
  double energy_gau = 0., energy_gcp = 0., energy = 0.;
  double xGrad_gau = 0., yGrad_gau = 0., zGrad_gau = 0.;
  double xGrad_gcp = 0., yGrad_gcp = 0., zGrad_gcp = 0.;
  double xGrad = 0., yGrad = 0., zGrad = 0.;
  double xDipo = 0., yDipo = 0., zDipo = 0.;
  unsigned int i = 0;
  int nzerolines = 0;
  /*  Only Fortran 95 and later introduced unsigned int,  */
  /*  hence only int is declared here.  */
  /*  But remember this should never be negative.  */
  char outname[BUFSIZ] = "";

  /*  acquire number of atoms and gradients  */
  iflp0 = fopen(argv[1], "r");
  fgets(line, BUFSIZ, iflp0);
  sscanf(line, "%u %u", & natoms, & ngrad);
  fclose(iflp0);
  iflp0 = NULL;

  /*  acquire Gaussian energy  */
  iflp1 = fopen("useExtGau.out", "r");
  while (! feof(iflp1))
  {
    fgets(line, BUFSIZ, iflp1);
    if (strstr(line, "SCF Done"))
    {
      sscanf(strchr(line, '=') + strlen("="), "%lf", & energy_gau);
      break;
    }
  }
  fseek(iflp1, 0, SEEK_SET);

  /*  acquire gCP energy */
  iflp2 = fopen("useExtgCP.out", "r");
  while (! feof(iflp2))
  {
    fgets(line, BUFSIZ, iflp2);
    if (strstr(line, "Egcp"))
    {
      sscanf(strstr(line, "Egcp") + strlen("Egcp:"), "%lf", & energy_gcp);
      break;
    }
  }
  fclose(iflp2);
  iflp2 = NULL;

  /*  total energy  */
  /*  changed here!!!  */
  /*  energy = energy_gau + energy_gcp;  */
  energy = energy_gau;

  /*  dipole-moment, without gCP  */
  while (! feof(iflp1))
  {
    fgets(line, BUFSIZ, iflp1);
    if (strstr(line, "Dipole moment (field-independent basis, Debye)"))
    {
      fgets(line, BUFSIZ, iflp1);
      sscanf(strchr(line, 'X'), "X= %lf Y= %lf Z= %lf", & xDipo, & yDipo, & zDipo);
      break;
    }
  }
  fseek(iflp1, 0, SEEK_SET);
  writeextspout_(& energy, & xDipo, & yDipo, & zDipo);

  /*  if 1st derivatives are needed  */
  if (ngrad >= 1)
  {
    iflp3 = fopen("gcp_gradient", "r");
    while (! feof(iflp1))
    {
      fgets(line, BUFSIZ, iflp1);
      if (strstr(line, "Forces (Hartrees/Bohr)"))
        break;
    }
    /*  two lines are useless  */
    fgets(line, BUFSIZ, iflp1);
    fgets(line, BUFSIZ, iflp1);
    for (i = 1; i <= natoms; i ++)
    {
      fgets(line, BUFSIZ, iflp1);
      /*  the next line actually reads force, which is the opposite number of gradient.  */
      sscanf(line, "%*d %*d %lf %lf %lf", & xGrad_gau, & yGrad_gau, & zGrad_gau);
      xGrad_gau = - xGrad_gau;
      yGrad_gau = - yGrad_gau;
      zGrad_gau = - zGrad_gau;
      fgets(line, BUFSIZ, iflp3);
      readgcpgrad_(line, & xGrad_gcp, & yGrad_gcp, & zGrad_gcp);
      xGrad = xGrad_gau + xGrad_gcp;
      yGrad = yGrad_gau + yGrad_gcp;
      zGrad = zGrad_gau + zGrad_gcp;
      writeextgradout_(& xGrad, & yGrad, & zGrad);
    }
    fclose(iflp3);
    iflp3 = NULL;
    fseek(iflp1, 0, SEEK_SET);
  }

  /*  polarizability and dipole derivatives, not calculated, just write 0  */
  /*  polarizability  */
  nzerolines = 6 / 3;
  write3zeros_(& nzerolines);
  nzerolines = 9 / 3;
  for (i = 0; i < natoms; i ++)    
    write3zeros_(& nzerolines);

  /* if 2nd derivatives are needed, this function has not been completed yet.  */
  if (ngrad >= 2)
    ;

  /*  file iflp1 has not been closed yet. close it.  */
  fclose(iflp1);
  iflp1 = NULL;

  return 0;
}

